<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1,user-scalable=no" />
<title>Detty Dice</title>

<!-- Fonts -->
<link href="https://fonts.googleapis.com/css2?family=Press+Start+2P&family=Montserrat:wght@500;700&display=swap" rel="stylesheet">

<style>
:root{
  --bg:#0e0e0e;
  --glass-bg: rgba(255,255,255,0.04);
  --accent1:#FF1493;
  --accent2:#FF8C00;
  --green1:#00e676;
  --muted:#aaa;
  --glass-border: rgba(255,255,255,0.08);
}

*{box-sizing:border-box}
html,body {height:100%;margin:0;background:var(--bg);color:#fff;font-family:'Montserrat',sans-serif; -webkit-font-smoothing:antialiased;-moz-osx-font-smoothing:grayscale}
body {display:flex;justify-content:center;align-items:flex-start;padding:18px 0 120px; touch-action:manipulation; -webkit-tap-highlight-color: transparent; overflow-x:hidden;}
#appWrapper {width:100%;max-width:480px;display:flex;flex-direction:column;align-items:center;}

/* header */
#gameHeader{text-align:center;margin-top:6px;}
#welcomeText{font-family:'Press Start 2P',cursive;font-size:11px;color:var(--accent1)}
#scrambleText{font-family:'Press Start 2P',cursive;font-size:20px;color:var(--accent1);margin-top:4px}

/* glass terminal (tap stats + timer etc) */
.glass-terminal {
  width: 90%;
  max-width: 420px;
  margin: 18px auto;
  padding: 14px 16px;
  background: var(--glass-bg);
  border: 1px solid var(--glass-border);
  border-radius: 14px;
  backdrop-filter: blur(8px);
  -webkit-backdrop-filter: blur(8px);
  box-shadow: 0 0 20px rgba(0,0,0,0.6);
  color: #fff;
  position: relative;
  overflow: hidden;
}
.terminal-header { text-align:center; color:var(--accent1); font-size:11px; letter-spacing:2px; margin-bottom:8px; font-weight:700; }
.terminal-line { font-size:13px; line-height:1.6; letter-spacing:1px; color:#fff; margin-bottom:6px; display:flex; justify-content:space-between; align-items:center; }
.terminal-line span { color:#00FF99; text-shadow:0 0 6px rgba(0,255,153,0.08); font-weight:700; }

/* train bar (timer visual) */
#trainBarContainer {
  width:100%;
  height:14px;
  background: rgba(255,255,255,0.03);
  border-radius: 999px;
  overflow:hidden;
  margin-top:8px;
}
#trainBar {
  height:100%;
  width:100%;
  background: linear-gradient(90deg, var(--accent1), var(--accent2));
  transform-origin: left center;
  transition: width 0.2s linear;
}

/* stats row inside terminal */
.stats-row { display:flex; justify-content:space-between; gap:12px; margin-top:8px; align-items:center; }
.stat { flex:1; background: rgba(255,255,255,0.02); padding:8px; border-radius:8px; text-align:center; }
.stat .label { font-size:11px; color:var(--muted); }
.stat .value { font-size:16px; font-weight:800; color:#fff; }

/* bonus bar (progress toward next bonus level) */
#bonusContainer { width:100%; height:10px; background:#111; border-radius:999px; overflow:hidden; margin-top:12px; box-shadow:0 6px 16px rgba(0,0,0,0.6) inset; }
#bonusBar { height:100%; width:0%; background:linear-gradient(90deg,var(--green1),#00b0ff); transition:width .15s linear; }

/* ROLL button - small round, far from terminal */
#rollButton {
  width:64px;
  height:64px;
  border-radius:50%;
  background: radial-gradient(circle at 25% 25%, var(--green1), #00b0ff);
  border: none;
  margin-top:36px; /* far from terminal */
  box-shadow: 0 8px 30px rgba(0,230,118,0.14);
  display:inline-flex;
  align-items:center;
  justify-content:center;
  font-weight:800;
  color:#000;
  font-size:18px;
  -webkit-user-select:none;
  user-select:none;
  -webkit-tap-highlight-color: transparent;
}

/* roll hover/active */
#rollButton:active { transform: scale(.96); }

/* tap count + earnings small status (below button) */
#miniStats { margin-top:12px; color:#fff; font-weight:700; }

/* leaderboard button */
#leaderboardBtn {
  margin-top:14px;
  padding:10px 14px;
  border-radius:10px;
  background: linear-gradient(90deg,#FFD700,#FF8C00);
  color:#111;
  font-weight:800;
  border:none;
  cursor:pointer;
  font-size:14px;
}

/* modal (normal fade-in centered) */
.modal-backdrop {
  position:fixed; inset:0; background: rgba(0,0,0,0.6); display:none; align-items:center; justify-content:center; z-index:9999;
}
.modal {
  width:92%; max-width:420px; background:#0f0f0f; border-radius:12px; padding:16px; border:1px solid rgba(255,255,255,0.06);
  box-shadow: 0 10px 30px rgba(0,0,0,0.6);
}
.modal h3{ margin:0 0 8px 0; color:var(--accent1); font-size:16px; }
.modal .list { text-align:left; margin-top:12px; max-height:320px; overflow:auto; }
.modal .list li { padding:8px 6px; border-bottom:1px dashed rgba(255,255,255,0.03); font-weight:700; }

/* result panel (small) */
#resultModalInner { display:none; margin-top:18px; }

/* small helpers */
.hidden { display:none!important; }
button, input { font-size:16px; } /* prevents iOS zoom on tap */
.active-tab {
  background: linear-gradient(90deg,#FF1493,#FF8C00);
  color: #fff;
  font-weight: bold;
}
body {
  height: 100%;
  margin: 0;
  font-family: 'Montserrat', sans-serif;
  -webkit-font-smoothing: antialiased;
  -moz-osx-font-smoothing: grayscale;
  display: flex;
  justify-content: center;
  align-items: flex-start;
  padding: 18px 0 120px;
  touch-action: manipulation;
  -webkit-tap-highlight-color: transparent;
  overflow-x: hidden;

  /* blur effect */
  position: relative;
}

body::before {
  content: '';
  position: fixed;
  top: 0;
  left: 0;
  width: 100%;
  height: 100%;
  backdrop-filter: blur(8px);
  -webkit-backdrop-filter: blur(8px);
  z-index: -1; /* behind content */
}

body.start-mode {
  background: url('https://cdn.shopify.com/s/files/1/0962/6648/6067/files/9F6F9EAC-F165-4C70-85CB-B2351A3B8C59.png?v=1763282422') no-repeat center center fixed;
  background-size: cover;
}

body.start-mode::before {
  display: none;
}

body.game-mode {
  background: url('https://cdn.shopify.com/s/files/1/0962/6648/6067/files/64EB80F3-9BE7-4D39-8C96-5608B941E4DC.png?v=1763280746') no-repeat center center fixed;
  background-size: cover;
}

.lb-row {
  display: flex;
  align-items: center;
  gap: 12px;
  margin-bottom: 6px;
  padding: 8px 10px;
  border-radius: 8px;
}

.lb-avatar {
  width: 40px;
  height: 40px;
  border-radius: 10px;
  object-fit: cover;
}

.lb-info {
  display: flex;
  flex-direction: column;
}

.lb-name {
  font-size: 14px;
  font-weight: 600;
}

.lb-score {
  font-size: 12px;
  opacity: 0.7;
}
/* Slider container */
.slider-wrapper {
  overflow: hidden;
  width: 100%;
  position: relative;
}

/* Track that moves */
.slider-track {
  display: flex;
  transition: transform 0.6s ease; /* smooth sliding */
  width: 100%;
}

/* Each slide */
.leaderboard-slide {
  width: 100%;
  flex-shrink: 0;
}
</style>
</head>
<body>
<div id="appWrapper">

  <!-- Header -->
  <div id="gameHeader">
    <div id="welcomeText">WELCOME TO</div>
    <div id="scrambleText">DETTY DICE</div>
  </div>
  

<!-- Start Page -->
<div id="startPage" style="width:100%;display:flex;flex-direction:column;align-items:center;margin-top:18px;">
  <button id="startBtn" style="padding:12px 22px;border-radius:12px;background:linear-gradient(90deg,#00e676,#00b0ff);color:#000;font-weight:800;font-size:16px;border:none;cursor:pointer;">Play</button>
</div>

<!-- Play Confirmation Modal -->
<div id="playModal" style="display:none;position:fixed;top:0;left:0;width:100%;height:100%;background:rgba(0,0,0,0.6);z-index:2000;justify-content:center;align-items:center;display:flex;">
  <div style="background:#111;color:#fff;padding:20px;border-radius:12px;width:90%;max-width:320px;text-align:center;">
    <h3 style="margin-bottom:12px;">Confirm Play</h3>
    <p>Play Detty Dice for <strong>10 ‚≠ê</strong>?</p>
    <div style="display:flex;justify-content:space-between;margin-top:18px;">
      <button id="cancelPlay" style="flex:1;margin-right:6px;padding:10px 12px;border:none;border-radius:8px;background:#444;color:#fff;font-weight:700;cursor:pointer;">Cancel</button>
      <button id="confirmPlay" style="flex:1;margin-left:6px;padding:10px 12px;border:none;border-radius:8px;background:linear-gradient(90deg,#00e676,#00b0ff);color:#000;font-weight:700;cursor:pointer;">Confirm</button>
    </div>
  </div>
</div>

  <!-- Spinner (loading animation) -->
  <div id="spinner" class="hidden" style="margin-top:18px;">
    <div style="width:44px;height:44px;border-radius:50%;border:6px solid #222;border-top:6px solid #00e676; animation:spin 1s linear infinite;margin:0 auto"></div>
    <div style="margin-top:10px;color:#aaa;font-size:13px">Loading Dice Arena‚Ä¶</div>
  </div>
  
  

  <!-- Game UI -->
  <div id="gamePage" class="hidden" style="width:100%;display:flex;flex-direction:column;align-items:center;">

    <!-- Glass terminal -->
    <div id="tapTerminal" class="glass-terminal" aria-live="polite">
      <div class="terminal-header">DICE TERMINAL</div>

      <div class="terminal-line">
        <div>‚è± Rolls Left</div>
        <div><span id="rollsLeft">25</span></div>
      </div>

      <div class="terminal-line">
        <div>üé≤ Total Score</div>
        <div><span id="totalScore">0</span></div>
      </div>

      <div class="terminal-line">
        <div>üíµ Earnings</div>
        <div>‚Ç¶<span id="earnings">0.00</span></div>
      </div>

      <div id="trainBarContainer" style="margin-top:10px;">
        <div id="trainBar" style="width:100%"></div>
      </div>
    </div>

<div id="diceScene" style="width:90%; height:300px; margin-top:20px;"></div>
<button id="rollButton" aria-label="Roll" title="Roll!">
  Roll
</button>
  
    <!-- Result modal -->
<div id="resultModal" class="modal-backdrop" style="display:none;align-items:center;justify-content:center;">
  <div class="modal" style="padding:16px;border-radius:12px;max-width:380px;text-align:center;position:relative;">
    <button id="closeResult" style="position:absolute;top:8px;right:8px;font-size:18px;border:none;background:none;cursor:pointer;">‚úñ</button>
    <div id="resultMessage" style="margin-top:10px;font-size:16px;font-weight:600;"></div>
    <button id="playAgainBtn" style="margin-top:16px;padding:10px 16px;border-radius:8px;border:none;background:linear-gradient(90deg,#00e676,#00b0ff);color:#000;font-weight:800;cursor:pointer;">Play Again</button>
  </div>
</div>

  </div> <!-- end gamePage -->

 <!-- Fixed bottom profile + leaderboard button -->
<div id="bottomBar" style="
  position:fixed;bottom:0;left:50%;transform:translateX(-50%);
  width:90%;max-width:480px;display:flex;flex-direction:column;
  align-items:center;gap:6px;z-index:1000;
">

  <!-- GLASS PROFILE CARD (unchanged) -->
  <div class="profile-card" 
    style="
      background:rgba(255,255,255,0.04);
      padding:10px;
      border-radius:10px;
      border:1px solid rgba(255,255,255,0.04);
      text-align:center;
      backdrop-filter:blur(8px);
      -webkit-backdrop-filter:blur(8px);
      width:100%;
    "
  >
      <div class="profile-name" id="profileName" style="font-size:15px;color:#fff;">
        GUEST 0000
      </div>

      <div class="profile-info" style="margin-top:6px;font-size:14px;">
        <strong style="background:linear-gradient(90deg,#00e676,#00b0ff);
                       -webkit-background-clip:text;
                       -webkit-text-fill-color:transparent;">
          STARS COLLECTED:
        </strong>
        <span id="starCount" style="color:#fff;">50</span>‚≠ê
      </div>

      <div class="profile-info" style="margin-top:2px;font-size:14px;">
        <strong style="background:linear-gradient(90deg,#00e676,#00b0ff);
                       -webkit-background-clip:text;
                       -webkit-text-fill-color:transparent;">
          CASH EARNED:
        </strong>
        <span id="cashCount" style="color:#fff;">0</span>
      </div>
  </div>

  <!-- LEADERBOARD BUTTON -->
  <button id="leaderboardBtn" 
    style="
      padding:10px 14px;
      border-radius:10px;
      background:linear-gradient(90deg,#FFD700,#FF8C00);
      color:#111;font-weight:800;
      border:none;cursor:pointer;
      font-size:14px;
    "
  >
    Leaderboard üèÜ
  </button>

</div>


  <!-- Leaderboard Modal -->
<div id="leaderboardModal" class="modal-backdrop" role="dialog" aria-modal="true"
     style="display:none;position:fixed;top:0;left:0;width:100%;height:100%;
            background:rgba(0,0,0,0.6);backdrop-filter:blur(3px);
            justify-content:center;align-items:center;z-index:9999;">

  <div class="modal"
       style="width:92%;max-width:420px;max-height:90vh;overflow:hidden;
              background:#111;border-radius:14px;padding:15px;
              box-shadow:0 0 15px rgba(0,0,0,0.4);display:flex;flex-direction:column;">

    <!-- Tabs -->
    <div id="leaderboardTabs" style="display:flex;gap:10px;margin-bottom:12px;">
      <button class="lb-tab active" data-period="daily"
        style="flex:1;padding:8px 0;border-radius:8px;border:none;
               background:#ff1493;color:#fff;font-weight:700;cursor:pointer;">
        Today
      </button>

      <button class="lb-tab" data-period="weekly"
        style="flex:1;padding:8px 0;border-radius:8px;border:none;
               background:#222;color:#ccc;font-weight:700;cursor:pointer;">
        This Week
      </button>

      <button class="lb-tab" data-period="monthly"
        style="flex:1;padding:8px 0;border-radius:8px;border:none;
               background:#222;color:#ccc;font-weight:700;cursor:pointer;">
        This Month
      </button>
    </div>

    <!-- DAILY TIMER -->
    <div id="dailyTimer" style="text-align:center;font-size:14px;font-weight:600;color:#ff8c00;margin-bottom:10px;display:block;">
      Reset in: <span id="dailyTimerValue">23:59:59</span>
    </div>

 <!-- Image Slider -->
<div id="leaderboardImageSlider"
     style="position:relative;width:100%;height:180px;overflow:hidden;border-radius:8px;margin-bottom:10px;touch-action:pan-y;">

  <div class="slider-track" style="display:flex;width:100%;height:100%;transition:transform 0.6s ease;">

    <img src="https://cdn.shopify.com/s/files/1/0962/6648/6067/files/STRZ.jpg?v=1763196570"
         class="leaderboard-slide"
         style="width:100%;height:100%;object-fit:cover;flex-shrink:0;">

    <img src="https://cdn.shopify.com/s/files/1/0962/6648/6067/files/STRZ.jpg?v=1763196570"
         class="leaderboard-slide"
         style="width:100%;height:100%;object-fit:cover;flex-shrink:0;">

    <img src="https://cdn.shopify.com/s/files/1/0962/6648/6067/files/STRZ.jpg?v=1763196570"
         class="leaderboard-slide"
         style="width:100%;height:100%;object-fit:cover;flex-shrink:0;">

    <img src="https://cdn.shopify.com/s/files/1/0962/6648/6067/files/STRZ.jpg?v=1763196570"
         class="leaderboard-slide"
         style="width:100%;height:100%;object-fit:cover;flex-shrink:0;">

    <img src="https://cdn.shopify.com/s/files/1/0962/6648/6067/files/STRZ.jpg?v=1763196570"
         class="leaderboard-slide"
         style="width:100%;height:100%;object-fit:cover;flex-shrink:0;">

    <img src="https://cdn.shopify.com/s/files/1/0962/6648/6067/files/STRZ.jpg?v=1763196570"
         class="leaderboard-slide"
         style="width:100%;height:100%;object-fit:cover;flex-shrink:0;">

    <img src="https://cdn.shopify.com/s/files/1/0962/6648/6067/files/STRZ.jpg?v=1763196570"
         class="leaderboard-slide"
         style="width:100%;height:100%;object-fit:cover;flex-shrink:0;">

  </div>
</div>

    <!-- Description -->
    <p id="leaderboardDescription"
       style="font-size:14px;color:#ccc;line-height:1.4;margin-bottom:10px;">
      Today's top rollers dominate the board. Roll high and stay ahead!
    </p>

    <!-- Scrollable List -->
    <ol id="leaderboardList"
        style="list-style:none;padding-left:0;margin:0;flex:1;overflow-y:auto;
               border-top:1px solid #222;padding-top:10px;">
    </ol>

    <!-- Close Button -->
    <div style="margin-top:12px;text-align:right;">
      <button id="closeLeaderboard"
        style="padding:8px 12px;border-radius:8px;border:none;
               background:linear-gradient(90deg,#FF1493,#FF8C00);
               color:#fff;font-weight:800;cursor:pointer;">
        Close
      </button>
    </div>

  </div>
</div>

<!-- Audio -->
<audio id="rollSound" src="https://actions.google.com/sounds/v1/cartoon/wood_plank_flicks.ogg" preload="auto"></audio>

<audio id="gameMusic" loop preload="auto">
  <source src="night_city_jazz.mp3" type="audio/mpeg">
</audio>

<script type="module">
import { initializeApp } from "https://www.gstatic.com/firebasejs/11.0.1/firebase-app.js";
import { 
  getFirestore, 
  doc, 
  getDoc, 
  runTransaction, 
  collection, 
  addDoc, 
  serverTimestamp,
  getDocs,     // <-- needed for reading queries
  query,       // <-- needed for queries
  where        // <-- needed for filtering
} from "https://www.gstatic.com/firebasejs/11.0.1/firebase-firestore.js";

import * as THREE from 'https://unpkg.com/three@0.159.0/build/three.module.js';
import * as CANNON from 'https://unpkg.com/cannon-es';
import * as BufferGeometryUtils from 'https://unpkg.com/three@0.159.0/examples/jsm/utils/BufferGeometryUtils.js';



// ---------- FIREBASE ----------
const firebaseConfig = {
  apiKey: "AIzaSyDbKz4ef_eUDlCukjmnK38sOwueYuzqoao",
  authDomain: "metaverse-1010.firebaseapp.com",
  projectId: "metaverse-1010",
  storageBucket: "metaverse-1010.appspot.com",
  messagingSenderId: "1044064238233",
  appId: "1:1044064238233:web:2fbdfb811cb0a3ba349608",
  measurementId: "G-S77BMC266C",
  databaseURL: "https://metaverse-1010-default-rtdb.firebaseio.com/"
};
const app = initializeApp(firebaseConfig);
const db = getFirestore(app);

// ---------- DOM ----------
const startBtn = document.getElementById('startBtn');
const playModal = document.getElementById('playModal');
const cancelPlay = document.getElementById('cancelPlay');
const confirmPlay = document.getElementById('confirmPlay');
const spinner = document.getElementById('spinner');
const startPage = document.getElementById('startPage');
const gamePage = document.getElementById('gamePage');
const rollButton = document.getElementById('rollButton');
const rollSound = document.getElementById('rollSound');
const rollsLeftEl = document.getElementById('rollsLeft');
const totalScoreEl = document.getElementById('totalScore');
const earningsEl = document.getElementById('earnings');
const trainBar = document.getElementById('trainBar');
const posterImg = document.getElementById('posterImg');
const starCountEl = document.getElementById('starCount');
const cashCountEl = document.getElementById('cashCount');
const profileNameEl = document.getElementById('profileName');

// ---------- END GAME MODAL ----------
const endGameModal = document.createElement('div');
endGameModal.id = "endGameModal";
endGameModal.style = `
  position:fixed; top:0; left:0; width:100%; height:100%;
  background:rgba(0,0,0,0.9); color:#fff; display:none;
  justify-content:center; align-items:center; z-index:9999; font-family:sans-serif;
`;
endGameModal.innerHTML = `
  <div style="background:#111; padding:30px; border-radius:15px; text-align:center; width:300px;">
    <h2>Game Over</h2>
    <p>Rolls: <span id="endRolls">0</span></p>
    <p>Total Score: <span id="endScore">0</span></p>
    <p>Earnings: ‚Ç¶<span id="endEarnings">0</span></p>
    <p>Average: x<span id="endAverage">0</span></p>
    <button id="closeEndGame" style="margin-top:15px; padding:10px 20px; border:none; border-radius:8px; background:#0f0; color:#000; font-weight:bold; cursor:pointer;">Close</button>
  </div>
`;
document.body.appendChild(endGameModal);

const endRollsEl = document.getElementById('endRolls');
const endScoreEl = document.getElementById('endScore');
const endEarningsEl = document.getElementById('endEarnings');
const endAverageEl = document.getElementById('endAverage');
const closeEndGameBtn = document.getElementById('closeEndGame');

closeEndGameBtn.addEventListener('click', () => {
  endGameModal.style.display = "none";
  gamePage.style.display = "none";
  startPage.style.display = "block";
  if(posterImg) posterImg.style.display = "block";
});

// ---------- CONFIG ----------
const STAR_COST = 10;
const DAILY_INITIAL_POT = 10000;
const CASH_PER_AWARD = 1;
const SESSION_ROLLS = 25;

// ---------- STATE ----------
let currentUser = null;
const tapEvent = ('ontouchstart' in window) ? 'touchstart' : 'click';

// ---------- LOCAL POT ----------
const KEY_POT = 'moneytrain_pot';
const KEY_RESET_DAY = 'moneytrain_reset_day';
function getStoredPot(){ return parseInt(localStorage.getItem(KEY_POT)) || null; }
function setStoredPot(v){ localStorage.setItem(KEY_POT, Math.max(0, Math.floor(v))); }
function getPotResetDay(){ return localStorage.getItem(KEY_RESET_DAY) || null; }
function setPotResetDay(s){ localStorage.setItem(KEY_RESET_DAY, s); }

function initializePot(){
  const today = new Date().toISOString().slice(0,10);
  if(!getStoredPot() || getPotResetDay() !== today){
    setStoredPot(DAILY_INITIAL_POT);
    setPotResetDay(today);
  }
}

function randomInt(min,max){ return Math.floor(Math.random()*(max-min+1))+min; }
function formatNumber(n){ return n.toLocaleString(); }

// ---------- LOAD USER ----------
async function loadCurrentUserForGame() {
  try {
    const vipRaw = localStorage.getItem("vipUser");
    const hostRaw = localStorage.getItem("hostUser");
    const storedUser = vipRaw ? JSON.parse(vipRaw) : hostRaw ? JSON.parse(hostRaw) : null;
    if(!storedUser?.email){
      currentUser=null;
      profileNameEl && (profileNameEl.textContent="GUEST 0000");
      starCountEl && (starCountEl.textContent="50");
      cashCountEl && (cashCountEl.textContent="‚Ç¶0");
      return;
    }
    const uid = storedUser.email.replace(/\./g,",").toLowerCase();
    const userRef = doc(db,"users",uid);
    const snap = await getDoc(userRef);
    if(!snap.exists()){
      currentUser = { uid, email: storedUser.email, chatId: storedUser.fullName||storedUser.displayName||storedUser.email.split("@")[0], stars:0, cash:0, totalScore:0 };
      profileNameEl && (profileNameEl.textContent=currentUser.chatId);
      starCountEl && (starCountEl.textContent="0");
      cashCountEl && (cashCountEl.textContent='‚Ç¶0');
      return;
    }
    const data = snap.data(); if(data.uid) delete data.uid;
    currentUser = { uid, ...data, stars:Number(data.stars||0), cash:Number(data.cash||0), totalScore:Number(data.totalScore||0) };
    profileNameEl && (profileNameEl.textContent=currentUser.chatId);
    starCountEl && (starCountEl.textContent=formatNumber(currentUser.stars));
    cashCountEl && (cashCountEl.textContent='‚Ç¶'+formatNumber(currentUser.cash));
  } catch(err){ console.warn("loadCurrentUserForGame error",err); }
}

// ---------- DEDUCT STARS ----------
async function tryDeductStarsForJoin(cost){
  if(!currentUser?.uid) return {ok:false,message:"You are not logged in"};
  const userRef = doc(db,"users",currentUser.uid);
  try{
    await runTransaction(db,async t=>{
      const u = await t.get(userRef);
      if(!u.exists()) throw new Error("User not found");
      const currentStars = Number(u.data().stars||0);
      if(currentStars<cost) throw new Error("Not enough stars");
      t.update(userRef,{stars:currentStars-cost});
      currentUser.stars = currentStars-cost;
    });
    starCountEl && (starCountEl.textContent=formatNumber(currentUser.stars));
    return {ok:true};
  } catch(e){ return {ok:false,message:e.message||"Could not deduct stars"}; }
}

// ---------- GIVE CASH ----------
async function giveCashToUser(amount){
  if(!currentUser?.uid) return {ok:false};
  const userRef = doc(db,"users",currentUser.uid);
  try{
    await runTransaction(db,async t=>{
      const u = await t.get(userRef);
      if(!u.exists()) throw new Error("User not found");
      const newCash = Number(u.data().cash||0) + Number(amount);
      t.update(userRef,{cash:newCash});
      currentUser.cash = newCash;
    });
    cashCountEl && (cashCountEl.textContent='‚Ç¶'+formatNumber(currentUser.cash));
    return {ok:true};
  } catch(e){ console.error("giveCashToUser error", e); return {ok:false,message:e.message}; }
}

// ---------- FLOATING +1 ----------
function showFloatingPlus(parent,text){
  const span=document.createElement('span');
  span.textContent=text;
  const rect = parent.getBoundingClientRect();
  const x = rect.left + Math.random() * rect.width * 0.6 + rect.width*0.2;
  const y = rect.top + Math.random() * rect.height * 0.6;
  Object.assign(span.style,{
    position:'absolute', fontWeight:'bold', color:'#fff', fontSize:'20px',
    pointerEvents:'none', userSelect:'none', zIndex:1000,
    top: y+'px', left: x+'px', opacity:1, transition:'all 0.9s ease-out'
  });
  document.body.appendChild(span);
  setTimeout(()=>{ span.style.top=(y-40)+'px'; span.style.opacity=0; },50);
  setTimeout(()=>span.remove(),900);
}

// ---------- CONFETTI ----------
function triggerConfetti(){
  for(let i=0;i<15;i++){
    const dot=document.createElement('div');
    Object.assign(dot.style,{
      position:'absolute', width:'6px', height:'6px',
      background:`hsl(${Math.random()*360},80%,60%)`,
      borderRadius:'50%', top: rollButton.offsetTop+'px',
      left: rollButton.offsetLeft + rollButton.offsetWidth/2+'px',
      pointerEvents:'none', zIndex:9999, opacity:1
    });
    document.body.appendChild(dot);
    const x=(Math.random()-0.5)*100; const y=-Math.random()*80;
    dot.animate([{transform:'translate(0,0)',opacity:1},{transform:`translate(${x}px,${y}px)`,opacity:0}],
      {duration:600, easing:'ease-out'});
    setTimeout(()=>dot.remove(),600);
  }
}

// ======================================================
//   SESSION ENGINE ‚Äî CLEAN, BULLETPROOF, DROP-IN
// ======================================================

// GLOBAL STATE
let rollsUsed = 0;
let totalScore = 0;
let earnings = 0;
let remainingRolls = SESSION_ROLLS;
let cashCounter = 0;
let cashThreshold = 0;

let running = false;
let rollLocked = false;
let isRolling = false;


// ======================================================
//   START SESSION
// ======================================================
function startSession() {

  // Reset state
  rollsUsed = 0;
  totalScore = 0;
  earnings = 0;
  remainingRolls = SESSION_ROLLS;
  cashCounter = 0;
  cashThreshold = randomInt(1, 12);

  running = true;
  rollLocked = false;
  rollButton.disabled = false;

  trainBar && (trainBar.style.width = "100%");
  updateUI();

  updateUI();
}



// ======================================================
//   INSTANT END ‚Äî UI FREEZE, BLOCK ROLLS
// ======================================================
function endSessionImmediate() {

  running = false;
  rollLocked = true;
  rollButton.disabled = true;

  // Fill modal
  endRollsEl.textContent = rollsUsed;
  endScoreEl.textContent = totalScore;
  endEarningsEl.textContent = formatNumber(earnings.toFixed(2));
  const average = rollsUsed > 0 ? totalScore / rollsUsed : 0;
  endAverageEl.textContent = average.toFixed(2);

  // Show modal immediately
  endGameModal.style.display = "flex";
}



// ======================================================
//   FIRESTORE ‚Äî ASYNC RECORDING
// ======================================================
async function endSessionRecord() {

  if (!currentUser?.uid || rollsUsed <= 0) return;

  try {
    const userRef = doc(db, "users", currentUser.uid);

    await runTransaction(db, async t => {

      const docSnap = await t.get(userRef);
      const now = new Date();

      const dailyKey = now.toISOString().split("T")[0];
      const weeklyKey = `${now.getFullYear()}-W${getWeek(now)}`;
      const monthlyKey = `${now.getFullYear()}-${String(now.getMonth()+1).padStart(2,"0")}`;

      if (!docSnap.exists()) {

        t.set(userRef, {
          chatId: currentUser.chatId || currentUser.uid,
          stars: currentUser.stars || 0,
          cash: currentUser.cash || 0,
          totalScore: totalScore,
          scoreDaily: { [dailyKey]: totalScore },
          scoreWeekly: { [weeklyKey]: totalScore },
          scoreMonthly: { [monthlyKey]: totalScore },
          lastEarnings: earnings,
        });

        return;
      }

      const data = docSnap.data();

      t.update(userRef, {
        totalScore: (data.totalScore || 0) + totalScore,
        scoreDaily: { ...(data.scoreDaily || {}), [dailyKey]: ((data.scoreDaily?.[dailyKey] || 0) + totalScore) },
        scoreWeekly: { ...(data.scoreWeekly || {}), [weeklyKey]: ((data.scoreWeekly?.[weeklyKey] || 0) + totalScore) },
        scoreMonthly: { ...(data.scoreMonthly || {}), [monthlyKey]: ((data.scoreMonthly?.[monthlyKey] || 0) + totalScore) },
        lastEarnings: earnings,
      });

    });

    await addDoc(collection(db, "detty_dice"), {
      uid: currentUser.uid,
      email: currentUser.email,
      chatId: currentUser.chatId || currentUser.uid,
      rollsUsed,
      totalScore,
      timestamp: serverTimestamp()
    });

    currentUser.totalScore = (currentUser.totalScore || 0) + totalScore;

    // Refresh leaderboard
    fetchLeaderboard("daily");

  } catch (err) {
    console.error("Error saving session:", err);
  }
}

// ======================================================
//   ROLL HANDLER ‚Äî NOW WITH COOL VIBES (Android) & iOS-SAFE
// ======================================================
rollButton?.addEventListener(tapEvent, async e => {

  e.preventDefault();

  if (!running || rollLocked || isRolling) return;

  rollLocked = true;
  setTimeout(() => rollLocked = false, 50);

  rollsUsed++;
  remainingRolls--;
  cashCounter++;
  showFloatingPlus(rollButton, "+Roll");

  // CASH AWARD
  if (cashCounter >= cashThreshold) {
    cashCounter = 0;
    cashThreshold = randomInt(1, 12);

    const pot = getStoredPot() ?? DAILY_INITIAL_POT;
    if (pot > 0) {
      earnings += CASH_PER_AWARD;
      setStoredPot(Math.max(0, pot - CASH_PER_AWARD));
      await giveCashToUser(CASH_PER_AWARD);
    }
  }

  isRolling = true;
  rollButton.disabled = true;
  throwDice();

  flashTapGlow();
  try { rollSound.currentTime = 0; rollSound.play().catch(()=>{}); } catch {}

  // COOL VIBRATION UPGRADE
  if ('vibrate' in navigator) {
    // Android: Snappy pattern for that premium tap feel
    navigator.vibrate([10, 5, 10]);
  }
  // iOS: Gracefully does nothing (no haptics possible via web)

  updateUI();
  if (remainingRolls <= 0) {
    endSessionImmediate();
    endSessionRecord();
  }
});


// ---------- UI & TAP GLOW ----------
function updateUI(){
  rollsLeftEl && (rollsLeftEl.textContent=String(remainingRolls));
  totalScoreEl && (totalScoreEl.textContent=String(totalScore));
  earningsEl && (earningsEl.textContent='‚Ç¶'+formatNumber(earnings.toFixed(2)));
  trainBar && (trainBar.style.width = ((SESSION_ROLLS - remainingRolls) / SESSION_ROLLS * 100) + "%");
  if(starCountEl && currentUser) starCountEl.textContent=formatNumber(currentUser.stars);
  if(cashCountEl && currentUser) cashCountEl.textContent='‚Ç¶'+formatNumber(currentUser.cash);
}

function flashTapGlow(){ 
  rollButton?.classList.add('tap-glow','tap-pulse'); 
  setTimeout(()=>{rollButton?.classList.remove('tap-glow','tap-pulse');},120); 
}

// ---------- CSS ----------
const style=document.createElement('style'); 
style.innerHTML=`
  #rollButton.tap-glow { box-shadow:0 0 26px rgba(0,230,118,0.9),0 0 8px rgba(0,176,255,0.6); }
  #rollButton.tap-pulse { transform: scale(1.05); transition: transform 0.12s ease; }
`;
document.head.appendChild(style);

// ---------- INITIALIZE ----------
initializePot();
loadCurrentUserForGame();

// ---------- START FLOW ----------
startBtn?.addEventListener("click",()=>{ if(playModal) playModal.style.display="flex"; });
cancelPlay?.addEventListener("click",()=>{ if(playModal) playModal.style.display="none"; });
confirmPlay?.addEventListener("click",async ()=>{
  let localStars=parseInt(starCountEl?.textContent.replace(/,/g,'')||"0",10);
  if(currentUser?.uid){
    const r=await tryDeductStarsForJoin(STAR_COST);
    if(!r.ok){ alert(r.message||"Not enough stars"); return; }
  } else {
    if(localStars<STAR_COST){ alert("Not enough stars"); return; }
    localStars-=STAR_COST; starCountEl.textContent=formatNumber(localStars);
  }
  if(playModal) playModal.style.display="none";
  if(posterImg) posterImg.style.display="none";
  if(startPage) startPage.style.display="none";
  if(spinner) spinner.classList.remove("hidden");
  setTimeout(()=>{
    if(spinner) spinner.classList.add("hidden");
    if(gamePage) gamePage.classList.remove("hidden");
    initThreeJs();
    startSession();
  },700);
});
/* ------------------------------
   LEADERBOARD SETUP (FIXED + CLEAN)
------------------------------- */

/* ---------- DOM ---------- */
const leaderboardBtn = document.getElementById("leaderboardBtn");
const leaderboardModal = document.getElementById("leaderboardModal");
const closeLeaderboard = document.getElementById("closeLeaderboard");
const leaderboardList = document.getElementById("leaderboardList");
const leaderboardSlides = document.querySelectorAll(".leaderboard-slide");
const leaderboardDescription = document.getElementById("leaderboardDescription");
const periodTabs = document.querySelectorAll(".lb-tab");
const dailyTimerContainer = document.getElementById("dailyTimer"); // FIXED


/* -------------------------------------------
   LEADERBOARD KEY HELPERS
-------------------------------------------- */
function getLeaderboardKey(period) {
  const now = new Date();
  if (period === "daily") return now.toISOString().split("T")[0];
  if (period === "weekly") return `${now.getFullYear()}-W${getWeek(now)}`;
  if (period === "monthly")
    return `${now.getFullYear()}-${String(now.getMonth() + 1).padStart(2, "0")}`;
  return null;
}

function getWeek(date) {
  const d = new Date(Date.UTC(date.getFullYear(), date.getMonth(), date.getDate()));
  const dayNum = d.getUTCDay() || 7;
  d.setUTCDate(d.getUTCDate() + 4 - dayNum);
  const yearStart = new Date(Date.UTC(d.getUTCFullYear(), 0, 1));
  return Math.ceil(((d - yearStart) / 86400000 + 1) / 7);
}


/* ------------------------------
   LEADERBOARD IMAGE SLIDER (FADE)
------------------------------- */
const sliderWrapper = document.getElementById("leaderboardImageSlider");
const sliderTrack = sliderWrapper.querySelector(".slider-track");
const slides = sliderWrapper.querySelectorAll(".leaderboard-slide");

let currentSlide = 0;
let slideInterval = null;
const slideCount = slides.length;

// Move slider to a given index
function showSlide(index) {
  currentSlide = index;
  sliderTrack.style.transform = `translateX(-${index * 100}%)`;
}

// Auto-slide every 3 seconds
function startSlider() {
  slideInterval = setInterval(() => {
    let next = (currentSlide + 1) % slideCount;
    showSlide(next);
  }, 3000);
}

function stopSlider() {
  clearInterval(slideInterval);
}

// Mobile swipe support
let startX = 0;

sliderWrapper.addEventListener("touchstart", e => {
  startX = e.touches[0].clientX;
  stopSlider();
});

sliderWrapper.addEventListener("touchend", e => {
  let endX = e.changedTouches[0].clientX;
  if (endX - startX > 50) {
    // swipe right
    let prev = (currentSlide - 1 + slideCount) % slideCount;
    showSlide(prev);
  }
  if (startX - endX > 50) {
    // swipe left
    let next = (currentSlide + 1) % slideCount;
    showSlide(next);
  }
  startSlider();
});

// Init
showSlide(0);
startSlider();

// Optional: stop when closing leaderboard modal
closeLeaderboard?.addEventListener("click", () => stopSlider());

/* -------------------------------------------
   FETCH LEADERBOARD
-------------------------------------------- */
async function fetchLeaderboard(period = "daily", top = 10) {
  leaderboardList.innerHTML = "<li>Loading...</li>";

  const key = getLeaderboardKey(period);
  const usersCol = collection(db, "users");

  try {
    const snap = await getDocs(usersCol);
    const scores = [];

    snap.forEach(docSnap => {
      const data = docSnap.data();

      let scoreCount = 0;
      if (period === "daily") scoreCount = data.scoreDaily?.[key] || 0;
      if (period === "weekly") scoreCount = data.scoreWeekly?.[key] || 0;
      if (period === "monthly") scoreCount = data.scoreMonthly?.[key] || 0;

      if (scoreCount > 0) {
        scores.push({
          uid: docSnap.id,
          chatId: data.chatId || docSnap.id.slice(0, 6),
          score: scoreCount,
        });
      }
    });

    scores.sort((a, b) => b.score - a.score);
    const topScores = scores.slice(0, top);

    if (topScores.length === 0) {
      leaderboardList.innerHTML = "<li>No data yet</li>";
      return;
    }

leaderboardList.innerHTML = topScores
  .map((u, i) => {
    const isCurrent = currentUser && u.uid === currentUser.uid;

    // ---- Avatar selection (random if no gender) ----
    const maleAvatar = "https://cdn.shopify.com/s/files/1/0000/0000/0000/files/avatar-male.png";
    const femaleAvatar = "https://cdn.shopify.com/s/files/1/0000/0000/0000/files/avatar-female.png";

    const avatar = u.gender === "female"
      ? femaleAvatar
      : u.gender === "male"
        ? maleAvatar
        : Math.random() < 0.5 ? maleAvatar : femaleAvatar;

    // ---- Capitalize first letter of each word ----
    const name = u.chatId || "Anon";
    const formattedName = name
      .split(" ")
      .map(n => n.charAt(0).toUpperCase() + n.slice(1).toLowerCase())
      .join(" ");

    // ---- Styles for ranks ----
    let style = "";
    if (i === 0) style = "color:#FFD700;font-weight:700;";
    else if (i === 1) style = "color:#C0C0C0;font-weight:700;";
    else if (i === 2) style = "color:#CD7F32;font-weight:700;";
    else if (isCurrent) style = "background:#333;padding:4px;border-radius:4px;";

    return `
      <li class="lb-row" style="${style}">
        <img class="lb-avatar" src="${avatar}" alt="avatar">
        <div class="lb-info">
          <span class="lb-name">${i + 1}. ${formattedName}</span>
          <span class="lb-score">${u.score.toLocaleString()} score</span>
        </div>
      </li>
    `;
  })
  .join("");
  } catch (err) {
    console.error("Leaderboard error:", err);
    leaderboardList.innerHTML = "<li>Error loading leaderboard</li>";
  }
}


/* -------------------------------------------
   TAB SWITCHER (CLEAN + FULLY WORKING)
-------------------------------------------- */
periodTabs.forEach(tab => {
  tab.addEventListener("click", () => {
    const period = tab.dataset.period;

    // Highlight active tab
    periodTabs.forEach(t => {
      t.classList.remove("active");
      t.style.background = "#222";
      t.style.color = "#ccc";
    });

    tab.classList.add("active");
    tab.style.background = "#ff1493";
    tab.style.color = "#fff";

    // Toggle timer
    dailyTimerContainer.style.display = period === "daily" ? "block" : "none";

    // Fetch leaderboard
    fetchLeaderboard(period);
  });
});


/* -------------------------------------------
   DAILY COUNTDOWN
-------------------------------------------- */
function startDailyCountdown() {
  const countdownEl = document.getElementById("dailyTimerValue");

  function updateCountdown() {
    const now = new Date();
    const nextReset = new Date();
    nextReset.setHours(24, 0, 0, 0);

    const diff = Math.max(0, Math.floor((nextReset - now) / 1000));

    const h = String(Math.floor(diff / 3600)).padStart(2, "0");
    const m = String(Math.floor((diff % 3600) / 60)).padStart(2, "0");
    const s = String(diff % 60).padStart(2, "0");

    countdownEl.textContent = `${h}:${m}:${s}`;
  }

  updateCountdown();
  setInterval(updateCountdown, 1000);
}


/* -------------------------------------------
   MODAL OPEN/CLOSE
-------------------------------------------- */
leaderboardBtn?.addEventListener("click", () => {
  leaderboardModal.style.display = "flex";

  startDailyCountdown();
  fetchLeaderboard("daily");

  // auto-switch active tab
  document.querySelector('.lb-tab[data-period="daily"]').click();
});

closeLeaderboard?.addEventListener("click", () => {
  leaderboardModal.style.display = "none";
});


let musicStarted = true;

function startGameMusic() {
  if (!musicStarted) {
    const audio = document.getElementById("gameMusic");
    audio.volume = 0.45; // perfect level behind tapping
    audio.play().catch(()=>{});
    musicStarted = true;
  }
}
document.addEventListener("click", startGameMusic);
document.addEventListener("touchstart", startGameMusic);

document.addEventListener('DOMContentLoaded', function() {
  const body = document.body;
  body.classList.add('start-mode');

  const startBtn = document.getElementById('startBtn');
  const playModal = document.getElementById('playModal');
  const cancelPlay = document.getElementById('cancelPlay');
  const confirmPlay = document.getElementById('confirmPlay');
  const startPage = document.getElementById('startPage');
  const gamePage = document.getElementById('gamePage');

  if (startBtn) {
    startBtn.addEventListener('click', function() {
      if (playModal) playModal.style.display = 'flex';
    });
  }

  if (cancelPlay) {
    cancelPlay.addEventListener('click', function() {
      if (playModal) playModal.style.display = 'none';
    });
  }

  if (confirmPlay) {
    confirmPlay.addEventListener('click', function() {
      if (playModal) playModal.style.display = 'none';
      if (startPage) startPage.classList.add('hidden');
      if (gamePage) gamePage.classList.remove('hidden');
      body.classList.remove('start-mode');
      body.classList.add('game-mode');
      // Add your game start logic here (e.g., timer, taps, etc.)
    });
  }
});
document.addEventListener("DOMContentLoaded", () => {

  // URL of your custom star SVG hosted on Shopify
  const customStarURL = "https://cdn.shopify.com/s/files/1/0962/6648/6067/files/starssvg.svg?v=1761770774";

  // Replace stars in text nodes with SVG + floating stars (invisible)
  function replaceStarsWithSVG(root = document.body) {
    if (!root) return;

    const walker = document.createTreeWalker(
      root,
      NodeFilter.SHOW_TEXT,
      {
        acceptNode: node => {
          if (node.nodeValue.includes("‚≠ê") || node.nodeValue.includes("‚≠êÔ∏è")) {
            return NodeFilter.FILTER_ACCEPT;
          }
          return NodeFilter.FILTER_REJECT;
        }
      }
    );

    const nodesToReplace = [];
    while (walker.nextNode()) nodesToReplace.push(walker.currentNode);

    nodesToReplace.forEach(textNode => {
      const parent = textNode.parentNode;
      if (!parent) return;

      const fragments = textNode.nodeValue.split(/‚≠êÔ∏è?|‚≠ê/);

      fragments.forEach((frag, i) => {
        if (frag) parent.insertBefore(document.createTextNode(frag), textNode);

        if (i < fragments.length - 1) {
          // Inline star
          const span = document.createElement("span");
          span.style.display = "inline-flex";
          span.style.alignItems = "center";
          span.style.position = "relative";

          const inlineStar = document.createElement("img");
          inlineStar.src = customStarURL;
          inlineStar.alt = "‚≠ê";
          inlineStar.style.width = "1.2em";
          inlineStar.style.height = "1.2em";
          inlineStar.style.display = "inline-block";
          inlineStar.style.verticalAlign = "text-bottom";
          inlineStar.style.transform = "translateY(0.15em) scale(1.2)";

          span.appendChild(inlineStar);
          parent.insertBefore(span, textNode);

          // Floating star (fully invisible)
          const floatingStar = document.createElement("img");
          floatingStar.src = customStarURL;
          floatingStar.alt = "‚≠ê";
          floatingStar.style.width = "40px";
          floatingStar.style.height = "40px";
          floatingStar.style.position = "absolute";
          floatingStar.style.pointerEvents = "none";
          floatingStar.style.zIndex = "9999";
          floatingStar.style.opacity = "0";
          floatingStar.style.transform = "translate(-50%, -50%)";

          const rect = inlineStar.getBoundingClientRect();
          floatingStar.style.top = `${rect.top + rect.height / 2 + window.scrollY}px`;
          floatingStar.style.left = `${rect.left + rect.width / 2 + window.scrollX}px`;

          document.body.appendChild(floatingStar);

          setTimeout(() => floatingStar.remove(), 1);
        }
      });

      parent.removeChild(textNode);
    });
  }

  // Observe dynamic content
  const observer = new MutationObserver(mutations => {
    mutations.forEach(m => {
      m.addedNodes.forEach(node => {
        if (node.nodeType === Node.TEXT_NODE) replaceStarsWithSVG(node.parentNode);
        else if (node.nodeType === Node.ELEMENT_NODE) replaceStarsWithSVG(node);
      });
    });
  });

  observer.observe(document.body, { childList: true, subtree: true });

  // Initial run
  replaceStarsWithSVG();

});

// ---------- 3D DICE SETUP ----------
const params = {
    segments: 50,
    edgeRadius: .07,
    notchRadius: 0.23,  // Derived from offset usage; adjust as needed
    notchDepth: 0.1     // Example value based on tutorial description; adjust for depth
};

let scene, camera, renderer;  
let physicsWorld;
let diceArray = [];  // Array to store { mesh, body } pairs
let diceMesh;  // Original dice mesh for cloning
let settledDice = 0;

function initThreeJs() {
  const container = document.getElementById('diceScene');
  const width = container.clientWidth;
  const height = container.clientHeight;

  scene = new THREE.Scene();
  camera = new THREE.PerspectiveCamera(70, width / height, 0.1, 1000);
  camera.position.set(0, 2, 3);
  camera.lookAt(0, 0, 0);

  renderer = new THREE.WebGLRenderer({ antialias: true });
  renderer.setSize(width, height);
  renderer.shadowMap.enabled = true;
  container.appendChild(renderer.domElement);

  const ambientLight = new THREE.AmbientLight(0xffffff, 0.5);
  scene.add(ambientLight);

  const pointLight = new THREE.PointLight(0xffffff, 1);
  pointLight.position.set(10, 10, 10);
  pointLight.castShadow = true;
  scene.add(pointLight);

  initPhysics();
  createFloor();
  initDice(2);  // 2 dice

  render();  // Start loop
}

function createDiceGeometry() {
    let boxGeometry = new THREE.BoxGeometry(1, 1, 1, params.segments, params.segments, params.segments);
    const positionAttribute = boxGeometry.attributes.position;

    const subCubeHalfSize = .5 - params.edgeRadius;
    const offset = .23;  // Offset for notch positioning

    for (let i = 0; i < positionAttribute.count; i++) {
        let position = new THREE.Vector3().fromBufferAttribute(positionAttribute, i);

        const subCube = new THREE.Vector3(Math.sign(position.x), Math.sign(position.y), Math.sign(position.z)).multiplyScalar(subCubeHalfSize);
        const addition = new THREE.Vector3().subVectors(position, subCube);

        if (Math.abs(position.x) > subCubeHalfSize && Math.abs(position.y) > subCubeHalfSize && Math.abs(position.z) > subCubeHalfSize) {
            addition.normalize().multiplyScalar(params.edgeRadius);
            position = subCube.add(addition);
        } else if (Math.abs(position.x) > subCubeHalfSize && Math.abs(position.y) > subCubeHalfSize) {
            addition.z = 0;
            addition.normalize().multiplyScalar(params.edgeRadius);
            position.x = subCube.x + addition.x;
            position.y = subCube.y + addition.y;
        } else if (Math.abs(position.x) > subCubeHalfSize && Math.abs(position.z) > subCubeHalfSize) {
            addition.y = 0;
            addition.normalize().multiplyScalar(params.edgeRadius);
            position.x = subCube.x + addition.x;
            position.z = subCube.z + addition.z;
        } else if (Math.abs(position.y) > subCubeHalfSize && Math.abs(position.z) > subCubeHalfSize) {
            addition.x = 0;
            addition.normalize().multiplyScalar(params.edgeRadius);
            position.y = subCube.y + addition.y;
            position.z = subCube.z + addition.z;
        }

        const notchWave = (v) => {
            v = (1 / params.notchRadius) * v;
            v = Math.PI * Math.max(-1, Math.min(1, v));
            return params.notchDepth * (Math.cos(v) + 1.);
        };
        const notch = (pos) => notchWave(pos[0]) * notchWave(pos[1]);

        if (position.y === .5) {
            position.y -= notch([position.x, position.z]);
        } else if (position.x === .5) {
            position.x -= notch([position.y + offset, position.z + offset]);
            position.x -= notch([position.y - offset, position.z - offset]);
        } else if (position.z === .5) {
            position.z -= notch([position.x - offset, position.y + offset]);
            position.z -= notch([position.x, position.y]);
            position.z -= notch([position.x + offset, position.y - offset]);
        } else if (position.z === -.5) {
            position.z += notch([position.x + offset, position.y + offset]);
            position.z += notch([position.x + offset, position.y - offset]);
            position.z += notch([position.x - offset, position.y + offset]);
            position.z += notch([position.x - offset, position.y - offset]);
        } else if (position.x === -.5) {
            position.x += notch([position.y + offset, position.z + offset]);
            position.x += notch([position.y + offset, position.z - offset]);
            position.x += notch([position.y, position.z]);
            position.x += notch([position.y - offset, position.z + offset]);
            position.x += notch([position.y - offset, position.z - offset]);
        } else if (position.y === -.5) {
            position.y += notch([position.x + offset, position.z + offset]);
            position.y += notch([position.x + offset, position.z]);
            position.y += notch([position.x + offset, position.z - offset]);
            position.y += notch([position.x - offset, position.z + offset]);
            position.y += notch([position.x - offset, position.z]);
            position.y += notch([position.x - offset, position.z - offset]);
        }

        positionAttribute.setXYZ(i, position.x, position.y, position.z);
    }

    boxGeometry.deleteAttribute('normal');
    boxGeometry.deleteAttribute('uv');
    boxGeometry = BufferGeometryUtils.mergeVertices(boxGeometry);
    boxGeometry.computeVertexNormals();

    return boxGeometry;
}

function createInnerGeometry() {
    const baseGeometry = new THREE.PlaneGeometry(1 - 2 * params.edgeRadius, 1 - 2 * params.edgeRadius);
    const offset = .48;  // Placement behind box sides

    return BufferGeometryUtils.mergeGeometries([
        baseGeometry.clone().translate(0, 0, offset),
        baseGeometry.clone().translate(0, 0, -offset),
        baseGeometry.clone().rotateX(.5 * Math.PI).translate(0, -offset, 0),
        baseGeometry.clone().rotateX(.5 * Math.PI).translate(0, offset, 0),
        baseGeometry.clone().rotateY(.5 * Math.PI).translate(-offset, 0, 0),
        baseGeometry.clone().rotateY(.5 * Math.PI).translate(offset, 0, 0),
    ], false);
}

function createDiceMesh() {
    const boxMaterialOuter = new THREE.MeshStandardMaterial({
        color: 0xeeeeee,
    });
    const boxMaterialInner = new THREE.MeshStandardMaterial({
        color: 0x000000,
        roughness: 0,
        metalness: 1,
        side: THREE.DoubleSide
    });

    const diceMeshGroup = new THREE.Group();
    const innerMesh = new THREE.Mesh(createInnerGeometry(), boxMaterialInner);
    const outerMesh = new THREE.Mesh(createDiceGeometry(), boxMaterialOuter);
    diceMeshGroup.add(innerMesh, outerMesh);

    return diceMeshGroup;
}

function initPhysics() {
    physicsWorld = new CANNON.World({
        gravity: new CANNON.Vec3(0, -50, 0),
        allowSleep: true,
    });
    physicsWorld.defaultContactMaterial.restitution = .3;
}

function createFloor() {
    // Three.js visual floor
    const floor = new THREE.Mesh(
        new THREE.PlaneGeometry(1000, 1000),
        new THREE.ShadowMaterial({
            opacity: .1
        })
    );
    floor.receiveShadow = true;
    floor.position.y = -7;
    floor.quaternion.setFromAxisAngle(new THREE.Vector3(-1, 0, 0), Math.PI * .5);
    scene.add(floor);

    // Cannon-es physical floor
    const floorBody = new CANNON.Body({
        type: CANNON.Body.STATIC,
        shape: new CANNON.Plane(),
    });
    floorBody.position.copy(floor.position);
    floorBody.quaternion.copy(floor.quaternion);
    physicsWorld.addBody(floorBody);
}

function createDice() {
    const mesh = diceMesh.clone();
    mesh.castShadow = true;
    scene.add(mesh);

    const body = new CANNON.Body({
        mass: 1,
        shape: new CANNON.Box(new CANNON.Vec3(.5, .5, .5)),  // Half-extent for Cannon-es
        sleepTimeLimit: .1  // 100ms sleep limit
    });
    physicsWorld.addBody(body);

    return { mesh, body };
}

// Initialize dice array (example for params.numberOfDice dice)
function initDice(numberOfDice) {
    diceMesh = createDiceMesh();  // Create original for cloning
    for (let i = 0; i < numberOfDice; i++) {
        const dice = createDice();
        diceArray.push(dice);
        addDiceEvents(dice);
    }
}

function addDiceEvents(dice) {
    dice.body.addEventListener('sleep', (e) => {
        // Only process if dice is actually sleeping (not just entering sleep state)
        if (!e.body.sleepState === CANNON.Body.SLEEPING) return;

        // Re-enable sleep only if it was disabled during throw
        dice.body.allowSleep = true;

        const euler = new CANNON.Vec3();
        e.body.quaternion.toEuler(euler);

        const eps = 0.1;
        let isZero = (angle) => Math.abs(angle) < eps;
        let isHalfPi = (angle) => Math.abs(angle - 0.5 * Math.PI) < eps;
        let isMinusHalfPi = (angle) => Math.abs(0.5 * Math.PI + angle) < eps;
        let isPiOrMinusPi = (angle) => Math.abs(Math.PI - angle) < eps || Math.abs(Math.PI + angle) < eps;

        let lyingOnSide = true;
        let result = 0;

        if (isZero(euler.z)) {
            if (isZero(euler.x)) result = 1;
            else if (isHalfPi(euler.x)) result = 4;
            else if (isMinusHalfPi(euler.x)) result = 3;
            else if (isPiOrMinusPi(euler.x)) result = 6;
            else lyingOnSide = false;
        } else if (isHalfPi(euler.z)) {
            result = 2;
        } else if (isMinusHalfPi(euler.z)) {
            result = 5;
        } else {
            lyingOnSide = false;
        }

        if (lyingOnSide) {
            dice.result = result;
            settledDice++;
            checkAllSettled();
        } else {
            // If on edge, wake up and let it fall
            dice.body.wakeUp();
        }
    });
}

setTimeout(() => {
    rollButton.classList.remove('tap-glow', 'tap-pulse');
}, 300);

function throwDice() {
    settledDice = 0;
    isRolling = true;
    rollButton.disabled = true;

    diceArray.forEach((d, dIdx) => {
        d.body.velocity.setZero();
        d.body.angularVelocity.setZero();
        d.body.allowSleep = true;  // Must allow sleep to detect settling
        d.body.sleep(); // Optional: force sleep reset
        d.body.wakeUp();

        d.body.position = new CANNON.Vec3(3 + dIdx * 1.5, 3, 0);
        d.mesh.position.copy(d.body.position);

        d.mesh.rotation.set(
            2 * Math.PI * Math.random(),
            2 * Math.PI * Math.random(),
            2 * Math.PI * Math.random()
        );
        d.body.quaternion.copy(d.mesh.quaternion);

        const force = 4 + 6 * Math.random();
        d.body.applyImpulse(
            new CANNON.Vec3(-force, force, (Math.random() - 0.5) * 2),
            new CANNON.Vec3(.2 * (Math.random() - 0.5), .3, .2 * (Math.random() - 0.5))
        );
    });
}

function render() {
    // Step physics world
    physicsWorld.fixedStep();

    // Sync visual meshes to physics bodies
    for (const dice of diceArray) {
        dice.mesh.position.copy(dice.body.position);
        dice.mesh.quaternion.copy(dice.body.quaternion);
    }

    // Render scene
    renderer.render(scene, camera);
    requestAnimationFrame(render);
}

</script>
</body>
</html>